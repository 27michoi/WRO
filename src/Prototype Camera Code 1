PROTOTYPE CODE 1:


#include <Servo.h>

Servo steeringServo;

// --- Pines del sistema ---
const int PIN_SERVO = 6;
const int ANGULO_CENTRO = 90;
const int PIN_PIEZO = 26;
const int ANGULO_GIRO_IZQ = 55;  // Ángulo arbitrario para esquivar obstáculos

// Pines del sensor ultrasónico frontal
const int PIN_TRIG_FRENTE = 2;
const int PIN_ECHO_FRENTE = 3;

// Pines para el control de motores
const int MOTOR_A_PWM = 7;
const int MOTOR_A_IN1 = 8;
const int MOTOR_A_IN2 = 9;

const int MOTOR_B_PWM = 12;
const int MOTOR_B_IN3 = 11;
const int MOTOR_B_IN4 = 10;

// --- FUNCIONES PERSONALIZADAS ---

// Gira el servo hacia un ángulo objetivo de forma progresiva
void moverServoA(int anguloObjetivo, int retardoPaso) {
  int anguloActual = steeringServo.read();
  
  // Giro hacia la derecha
  if (anguloObjetivo > anguloActual) {
    for (int ang = anguloActual; ang <= anguloObjetivo; ang += 5) {
      steeringServo.write(ang);
      delay(retardoPaso);
    }
  } 
  // Giro hacia la izquierda
  else if (anguloObjetivo < anguloActual) {
    for (int ang = anguloActual; ang >= anguloObjetivo; ang -= 3) {
      steeringServo.write(ang);
      delay(retardoPaso);
    }
  }
}

// Control de avance o retroceso de ambos motores
void moverMotores(int velocidadA, int velocidadB, bool adelante) {
  if (adelante) {
    digitalWrite(MOTOR_A_IN1, HIGH);
    digitalWrite(MOTOR_A_IN2, LOW);
    digitalWrite(MOTOR_B_IN3, HIGH);
    digitalWrite(MOTOR_B_IN4, LOW);
  } else {
    digitalWrite(MOTOR_A_IN1, LOW);
    digitalWrite(MOTOR_A_IN2, HIGH);
    digitalWrite(MOTOR_B_IN3, LOW);
    digitalWrite(MOTOR_B_IN4, HIGH);
  }

  analogWrite(MOTOR_A_PWM, velocidadA);
  analogWrite(MOTOR_B_PWM, velocidadB);
}

// Detiene los motores (ambos)
void frenarTodo() {
  analogWrite(MOTOR_A_PWM, 0);
  analogWrite(MOTOR_B_PWM, 0);
}

// Mide distancia con el sensor ultrasónico
long medirDistancia(int trig, int echo) {
  digitalWrite(trig, LOW);
  delayMicroseconds(3);  // antes era 2us, subí un poco por seguridad
  digitalWrite(trig, HIGH);
  delayMicroseconds(12); // antes era 10us, igual subí un poco
  digitalWrite(trig, LOW);

  long duracion = pulseIn(echo, HIGH);
  long distancia = duracion * 0.034 / 2;

  return distancia;
}

// Hace sonar el zumbador
void hacerBeep(int tono, int duracion) {
  tone(PIN_PIEZO, tono, duracion);
  delay(duracion + 10); // le agregué un poco más de margen
}

// --- SETUP DEL ROBOT ---
void setup() {
  Serial.begin(9600);

  // Configuración de pines de motor
  pinMode(MOTOR_A_PWM, OUTPUT);
  pinMode(MOTOR_A_IN1, OUTPUT);
  pinMode(MOTOR_A_IN2, OUTPUT);
  pinMode(MOTOR_B_PWM, OUTPUT);
  pinMode(MOTOR_B_IN3, OUTPUT);
  pinMode(MOTOR_B_IN4, OUTPUT);

  pinMode(PIN_PIEZO, OUTPUT);

  pinMode(PIN_TRIG_FRENTE, OUTPUT);
  pinMode(PIN_ECHO_FRENTE, INPUT);

  steeringServo.attach(PIN_SERVO);
  steeringServo.write(ANGULO_CENTRO);

  Serial.println("Sistema iniciado. Esperando...");
  delay(4000);  // Espera larga para debugging inicial
}

// --- LOOP PRINCIPAL ---
void loop() {
  long distanciaFrente = medirDistancia(PIN_TRIG_FRENTE, PIN_ECHO_FRENTE);

  // En caso de obstáculo cercano
  if (distanciaFrente > 0 && distanciaFrente < 20) {
    Serial.println("¡Obstáculo detectado! Intentando rodear...");

    frenarTodo();
    hacerBeep(950, 120);
    delay(400);

    moverServoA(ANGULO_GIRO_IZQ, 12);  // gira un poco a la izquierda
    moverMotores(115, 115, true);      // velocidad reducida para maniobra
    delay(1300);

    moverServoA(ANGULO_CENTRO, 10);    // vuelve al centro
    frenarTodo();
    delay(400);
  } 
  // Camino libre
  else {
    Serial.println("Camino libre. Avanzando.");
    moverServoA(ANGULO_CENTRO, 8);
    moverMotores(160, 160, true);  // Aceleración mayor en ausencia de obstáculos
  }
}
