#include <Servo.h>

// ====== Pines ======
const int SERVO_PIN = 6;
const int FRONT_TRIG_PIN = 2;
const int FRONT_ECHO_PIN = 3;

// L298N (Arduino Mega: 7 y 12 son PWM)
const int ENA = 7;
const int IN1 = 8;
const int IN2 = 9;
const int ENB = 12;
const int IN3 = 11;
const int IN4 = 10;

// Piezo
const int PIEZO_PIN = 26;

// ====== Config ======
const int   CENTER_ANGLE   = 90;
const int   LEFT_ANGLE     = 50;     // tu pedido
const int   SPEED_FWD      = 110;    // recta
const int   SPEED_TURN     = 70;     // al girar (más lento)
const int   SPEED_BACK     = 90;     // al retroceder
const long  THRESHOLD_CM   = 35;     // dispara a < 35 cm

// Tiempos (ajustables)
const int BEEP_MS          = 200;
const int BACK_MS          = 1800;    // retrocede un poco
const int TURN_MS          = 2000;    // <-- giro de 2.0 segundos (exacto)
const int STRAIGHTEN_MS    = 300;     
const int COOLDOWN_MS      = 400;     // evita múltiples triggers seguidos

// Estados para Serial Plotter (opcional)
enum State { FWD=1, ALERT=2, BACK=3, TURN=4, STRAIGHTEN=5, IDLE=6 };

Servo myservo;

// ====== Motores ======
void moveForward(int speedVal) {
  digitalWrite(IN1, HIGH); digitalWrite(IN2, LOW);
  digitalWrite(IN3, HIGH); digitalWrite(IN4, LOW);
  analogWrite(ENA, speedVal);
  analogWrite(ENB, speedVal);
}
void moveBackward(int speedVal) {
  digitalWrite(IN1, LOW);  digitalWrite(IN2, HIGH);
  digitalWrite(IN3, LOW);  digitalWrite(IN4, HIGH);
  analogWrite(ENA, speedVal);
  analogWrite(ENB, speedVal);
}
void stopMotors() {
  analogWrite(ENA, 0);
  analogWrite(ENB, 0);
}

// ====== Ultrasonido ======
long readDistanceOnceCm(int trigPin, int echoPin) {
  digitalWrite(trigPin, LOW);  delayMicroseconds(2);
  digitalWrite(trigPin, HIGH); delayMicroseconds(10);
  digitalWrite(trigPin, LOW);
  long us = pulseIn(echoPin, HIGH, 30000UL); // timeout 30 ms
  if (us == 0) return -1;
  return (us * 34L) / 2000L; // ≈ cm
}

// Detección “activa”: toma N lecturas rápidas y devuelve la mínima válida (la más cercana)
long readDistanceFilteredCm(int trigPin, int echoPin, uint8_t samples = 3, uint8_t gap_ms = 12) {
  long best = -1;
  for (uint8_t i = 0; i < samples; i++) {
    long d = readDistanceOnceCm(trigPin, echoPin);
    if (d > 0 && (best < 0 || d < best)) best = d;
    delay(gap_ms); // breve separación entre pings
  }
  return best; // -1 si todas fallaron
}

void printState(State s, const char* msg) {
  Serial.println(msg);
  Serial.print("state:"); Serial.println((int)s); // para Serial Plotter
}

void setup() {
  Serial.begin(115200);

  // Servo
  myservo.attach(SERVO_PIN);
  myservo.write(CENTER_ANGLE);

  // L298N
  pinMode(ENA, OUTPUT); pinMode(IN1, OUTPUT); pinMode(IN2, OUTPUT);
  pinMode(ENB, OUTPUT); pinMode(IN3, OUTPUT); pinMode(IN4, OUTPUT);
  stopMotors();

  // Ultrasonido frontal
  pinMode(FRONT_TRIG_PIN, OUTPUT);
  pinMode(FRONT_ECHO_PIN, INPUT);

  // Piezo
  pinMode(PIEZO_PIN, OUTPUT);

  Serial.println("READY: forward + ACTIVE front detection @ <35cm (beep, back, turn-left, straighten).");
}

void loop() {
  // Avanza por defecto
  myservo.write(CENTER_ANGLE);
  moveForward(SPEED_FWD);
  printState(FWD, "Forward...");

  // Polling mientras avanza (rápido y con filtro)
  while (true) {
    long dF = readDistanceFilteredCm(FRONT_TRIG_PIN, FRONT_ECHO_PIN, 3, 12);

    if (dF > 0 && dF < THRESHOLD_CM) {
      // --- ALERTA: obstáculo cerca ---
      Serial.print("Detected @ "); Serial.print(dF); Serial.println(" cm (<35)");
      printState(ALERT, "Beep + back + turn left");

      // Beep
      tone(PIEZO_PIN, 1000, BEEP_MS);
      delay(BEEP_MS + 10);
      noTone(PIEZO_PIN);

      // Retrocede un poco
      printState(BACK, "Backing...");
      moveBackward(SPEED_BACK);
      delay(BACK_MS);

      // Girar a la izquierda (servo a 50°) mientras avanza lento TURN_MS
      myservo.write(LEFT_ANGLE);
      printState(TURN, "Turning left (2.0s)...");
      moveForward(SPEED_TURN);
      delay(TURN_MS);

      // Enderezar (seguir avanzando mientras endereza)
      myservo.write(CENTER_ANGLE);
      printState(STRAIGHTEN, "Straightening...");
      delay(STRAIGHTEN_MS);

      // Cooldown para no disparar de inmediato de nuevo
      printState(IDLE, "Cooldown...");
      delay(COOLDOWN_MS);

      // Volver a bucle principal (seguirá en forward)
      break;
    }

    // pequeño respiro (detección más “activa”: 20–40 ms es buen rango)
    delay(25);
  }
}
